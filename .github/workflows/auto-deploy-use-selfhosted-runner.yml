# ================================================
# 機能概要
# -----------------------------------------------
# このワークフローはSelf-Hostedランナー上で、
# リポジトリ名から環境情報を解析し、タグ作成時または手動実行時に
# 資材を指定パスへデプロイします。
#
# 実行条件：
# ・"Auto Tag Processing"ワークフローからの呼び出し時（自動実行）
# ・workflow_dispatch（手動実行）
#
# 主な処理：
# ・リポジトリ名からデプロイ先情報を抽出
# ・テンプレートパス（vars）を変数で置換し配信先を決定
# ・.deployignore の設定に基づき、配信先をクリーンアップ
# ・.deployignore の設定に基づき、資材を配信先へ同期（rsync）
# ・エラー時は即時中断、全処理ログはActionsで確認可能
# ・最後にcheckout資材とログをクリーンアップ
# ================================================

name: Auto Deploy (Self-Hosted)

permissions:
  contents: read

on:
  workflow_dispatch: {}
  workflow_call:
    inputs:
      tag:
        required: true
        type: string

jobs:
  analyze-repository-name:
    runs-on: ubuntu-latest
    outputs:
      repo_type: ${{ steps.parse-name.outputs.repo_type }}
      molecule_no: ${{ steps.parse-name.outputs.molecule_no }}
      study_no: ${{ steps.parse-name.outputs.study_no }}
      reporting_event: ${{ steps.parse-name.outputs.reporting_event }}
      env_name: ${{ steps.parse-name.outputs.env_name }}
    steps:
      - name: Parse Repository Name
        id: parse-name
        run: |
          # Get pure repository name (remove owner/)
          REPO_NAME=$(echo "${{ github.repository }}" | awk -F '/' '{print $2}')
          echo "Analyzing Repository Name: $REPO_NAME"

          IFS='-' read -r -a parts <<< "$REPO_NAME"
          PARTS_LEN=${#parts[@]}

          # 3rd part (index 2) determines type S or M
          # Example S: AEGIS-PRD-S-RO1234567-STD0001-ReportingEvent1-dev
          # Example M: AEGIS-ZTEST-M-RO1234567-ReportingEvent2-dev

          if [ "$PARTS_LEN" -lt 3 ]; then
            echo "Error: Repository name must have at least 3 parts, got $PARTS_LEN."
            exit 1
          fi

          TYPE="${parts[2]}"

          if [ "$TYPE" == "S" ]; then
            if [ "$PARTS_LEN" -lt 7 ]; then
              echo "Error: Type S repository name must have at least 7 parts, got $PARTS_LEN."
              exit 1
            fi
            echo "Detected Type: S (Study)"
            MOLECULE_NO="${parts[3]}"
            STUDY_NO="${parts[4]}"
            EVENT_NAME="${parts[5]}"
            ENV_NAME="${parts[6]}"

            echo "repo_type=S" >> $GITHUB_OUTPUT            
            echo "molecule_no=$MOLECULE_NO" >> $GITHUB_OUTPUT
            echo "study_no=$STUDY_NO" >> $GITHUB_OUTPUT
            echo "reporting_event=$EVENT_NAME" >> $GITHUB_OUTPUT
            echo "env_name=$ENV_NAME" >> $GITHUB_OUTPUT

          elif [ "$TYPE" == "M" ]; then
            if [ "$PARTS_LEN" -lt 6 ]; then
              echo "Error: Type M repository name must have at least 6 parts, got $PARTS_LEN."
              exit 1
            fi
            echo "Detected Type: M (Molecule)"
            MOLECULE_NO="${parts[3]}"
            EVENT_NAME="${parts[4]}"
            ENV_NAME="${parts[5]}"

            echo "repo_type=M" >> $GITHUB_OUTPUT            
            echo "molecule_no=$MOLECULE_NO" >> $GITHUB_OUTPUT
            echo "study_no=" >> $GITHUB_OUTPUT
            echo "reporting_event=$EVENT_NAME" >> $GITHUB_OUTPUT
            echo "env_name=$ENV_NAME" >> $GITHUB_OUTPUT

          else
            echo "Error: Unknown repository name pattern. Type '$TYPE' is not S or M."
            exit 1
          fi

  deploy:
    needs: analyze-repository-name
    # Self-Hosted ランナーを指定（ラベルは環境に合わせて調整してください）
    runs-on:
      [
        self-hosted,
        linux,
        "${{ needs.analyze-repository-name.outputs.env_name }}"
      ]

    steps:
      - name: Determine ref to checkout
        id: set-ref
        run: |
          if [ -n "${{ inputs.tag }}" ]; then
            echo "REF=${{ inputs.tag }}" >> $GITHUB_ENV
            echo "Triggered by workflow_call. Using tag: ${{ inputs.tag }}"
          else
            echo "REF=${{ github.ref }}" >> $GITHUB_ENV
            echo "Triggered by workflow_dispatch or default. Using ref: ${{ github.ref }}"
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: checkoutDir
          ref: ${{ env.REF }}

      - name: Show ref info
        run: |
          echo "Checked out ref: $REF"

      - name: Prepare and Copy to Delivery Directory
        env:
          DELIVERY_DEST_S: ${{ vars.DELIVERY_DEST_S }}
          DELIVERY_DEST_M: ${{ vars.DELIVERY_DEST_M }}
          REPO_TYPE: ${{ needs.analyze-repository-name.outputs.repo_type }}
          MOLECULE_NO: ${{ needs.analyze-repository-name.outputs.molecule_no }}
          STUDY_NO: ${{ needs.analyze-repository-name.outputs.study_no }}
          REPORTING_EVENT: ${{ needs.analyze-repository-name.outputs.reporting_event }}
        run: |
          set -e
          LOG_FILE="deploy_report.log"
          START_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          echo "========================================" > "$LOG_FILE"
          echo "Deployment Report" >> "$LOG_FILE"
          echo "Start Time: $START_TIME" >> "$LOG_FILE"

          # 1. 配信先パスのテンプレートを選択
          if [ "$REPO_TYPE" = "S" ]; then
            DEST_TEMPLATE="$DELIVERY_DEST_S"
          elif [ "$REPO_TYPE" = "M" ]; then
            DEST_TEMPLATE="$DELIVERY_DEST_M"
          else
            echo "Error: Unknown repo_type: $REPO_TYPE" | tee -a "$LOG_FILE"
            exit 1
          fi

          # DEST_TEMPLATEが空かどうかをチェック
          if [ -z "$DEST_TEMPLATE" ]; then
            echo "Error: 配信先テンプレート(DELIVERY_DEST_S/M)が未設定です。" | tee -a "$LOG_FILE"
            exit 1
          fi

          # 2. テンプレート変数を置換
          DEST_PATH="$DEST_TEMPLATE"
          DEST_PATH="${DEST_PATH//<MoleculeNo>/$MOLECULE_NO}"
          DEST_PATH="${DEST_PATH//<StudyNo>/$STUDY_NO}"
          DEST_PATH="${DEST_PATH//<ReportingEventName>/$REPORTING_EVENT}"

          # DEST_PATHが存在するかどうかをチェック
          if [ ! -d "$DEST_PATH" ]; then
            echo "Error: 配信先ディレクトリが存在しません: $DEST_PATH" | tee -a "$LOG_FILE"
            exit 1
          fi

          echo "Target: $DEST_PATH" >> "$LOG_FILE"
          echo "========================================" >> "$LOG_FILE"

          # 3. .deployignoreから除外リストを読み込む
          DELETE_EXCLUDE_LIST=()
          COPY_EXCLUDE_LIST=()
          current_section=""
          while IFS= read -r line; do
            # コメント行と空行をスキップ
            [[ "$line" =~ ^#.*$ ]] && continue
            [[ -z "$line" ]] && continue

            # セクションの切り替えを検出
            if [[ "$line" == "[delete_exclude]" ]]; then
              current_section="delete"
              continue
            elif [[ "$line" == "[copy_exclude]" ]]; then
              current_section="copy"
              continue
            fi

            # 現在のセクションに応じてリストに追加
            if [[ "$current_section" == "delete" ]]; then
              item_name=${line#*:}
              DELETE_EXCLUDE_LIST+=("$item_name")
            elif [[ "$current_section" == "copy" ]]; then
              item_name=${line#*:}
              COPY_EXCLUDE_LIST+=("$item_name")
            fi
          done < checkoutDir/.github/.deployignore

          echo "Deletion Exclusions: ${DELETE_EXCLUDE_LIST[@]}" | tee -a "$LOG_FILE"
          echo "Copy Exclusions: ${COPY_EXCLUDE_LIST[@]}" | tee -a "$LOG_FILE"

          # 4. 配信先ディレクトリをクリーンアップする
          echo "Cleaning destination directory: $DEST_PATH" | tee -a "$LOG_FILE"
          for item in "$DEST_PATH"/*; do
            item_name=$(basename "$item")
            should_exclude=false
            for exclude_item in "${DELETE_EXCLUDE_LIST[@]}"; do
              if [[ "$item_name" == "$exclude_item" ]]; then
                should_exclude=true
                break
              fi
            done

            if [[ "$should_exclude" == "false" ]];
            then
              echo "Deleting $item" | tee -a "$LOG_FILE"
              rm -rf "$item"
            else
              echo "Skipping deletion of $item" | tee -a "$LOG_FILE"
            fi
          done

          # 5. checkoutDirからDEST_PATHへファイルをコピーする
          echo "Copying files from checkoutDir to $DEST_PATH" | tee -a "$LOG_FILE"
          rsync_exclude_opts=()
          for exclude in "${COPY_EXCLUDE_LIST[@]}"; do
            rsync_exclude_opts+=(--exclude "$exclude")
          done

          rsync -av --progress "${rsync_exclude_opts[@]}" checkoutDir/ "$DEST_PATH/" | tee -a "$LOG_FILE"
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "Error: Failed to copy files with rsync." | tee -a "$LOG_FILE"
            exit 1
          fi
          echo "Copied files to $DEST_PATH." >> "$LOG_FILE"

          END_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          echo "End Time: $END_TIME" >> "$LOG_FILE"
          echo "========================================" >> "$LOG_FILE"
          echo "Deployment completed successfully." | tee -a "$LOG_FILE"
          echo " "
          echo "▼▼▼▼▼▼▼▼▼▼ ログの詳細内容 ▼▼▼▼▼▼▼▼▼▼"
          cat "$LOG_FILE"
          echo "▲▲▲▲▲▲▲▲▲▲ ログの詳細内容 ▲▲▲▲▲▲▲▲▲▲"
          echo " "

          # 6. checkoutDirのクリーンアップ
          echo "Cleaning up checkoutDir..."
          rm -rf checkoutDir

          # 7. ログファイルの削除
          rm "$LOG_FILE"
